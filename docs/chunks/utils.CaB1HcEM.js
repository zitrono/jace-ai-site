import{c as createAstro,a as createComponent,r as renderTemplate,b as addAttribute,m as maybeRenderHead,d as renderComponent}from"./vendor-astro.MOr6Lc0B.js";import"kleur/colors";import"html-escaper";import"clsx";import{$ as $$Button}from"./primitives.CpQc7f5s.js";var _a$1,__freeze$1=Object.freeze,__defProp$1=Object.defineProperty,__template$1=(n,e)=>__freeze$1(__defProp$1(n,"raw",{value:__freeze$1(n.slice())}));const $$Astro$1=createAstro("https://zitrono.github.io"),$$CookieConsent=createComponent(((n,e,t)=>{const a=n.createAstro($$Astro$1,e,t);a.self=$$CookieConsent;const{class:o="",title:i="Cookie Preferences",message:s="We use cookies to enhance your experience. Choose your preferences below. Read about our privacy policy",privacyLink:r="/privacy",position:l="bottom-left",id:c="cookie-banner"}=a.props;return renderTemplate(_a$1||(_a$1=__template$1(["\x3c!-- Cookie Banner - initially hidden, positioned bottom-left --\x3e\x3c!-- Progressive Enhancement: Non-critical functionality loaded with client:idle --\x3e","<div","",' data-testid="cookie-consent-banner"> <div','> <div class="flex flex-col gap-3"> <div> <h2 class="mb-1 text-sm font-medium">','</h2> <p class="text-xs text-secondary"> '," <a"," target=\"_blank\" rel=\"noopener noreferrer\" class=\"text-white hover:text-gray-300 underline\">here</a>.\n</p> </div> <div class=\"flex gap-2 justify-between\"> <button id=\"cookie-settings\" class=\"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md font-medium focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 active:scale-[.99] underline-offset-4 hover:underline border-0 h-7 px-3 text-sm cursor-pointer text-white hover:text-gray-300\" aria-label=\"Open cookie settings\">\nSettings\n</button> <div class=\"flex gap-2\"> <button id=\"cookie-reject\" class=\"inline-flex items-center justify-center gap-2 border border-white/20 whitespace-nowrap rounded-md font-medium focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 active:scale-[.99] shadow-sm h-7 px-3 text-sm cursor-pointer text-white hover:bg-white/10\" aria-label=\"Reject all cookies\">\nReject\n</button> <button id=\"cookie-accept\" class=\"inline-flex items-center justify-center gap-2 border border-transparent whitespace-nowrap rounded-md font-medium focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 active:scale-[.99] shadow-sm h-7 px-3 text-sm cursor-pointer bg-accent text-accent-foreground hover:bg-accent/90\" aria-label=\"Accept all cookies\">\nAccept\n</button> </div> </div> </div> </div> </div> \x3c!-- Performance-optimized cookie consent with centralized state and focus management --\x3e <script type=\"module\">\n  import { cookieBannerSlideUp, cookieBannerSlideDown, initAnimationSystem } from '../../utils/animation-manager.js';\n  import { initializeStateManager } from '../../utils/state-manager.js';\n  import { FocusManager } from '../../utils/focus-manager.js';\n\n  // Optimized cookie consent functionality with centralized state and focus management\n  function initializeCookieConsent() {\n    // Initialize systems\n    initAnimationSystem();\n    const stateManager = initializeStateManager();\n    \n    // Check if consent was already given to avoid unnecessary operations\n    const existingConsent = localStorage.getItem('cookieConsent');\n    const banner = document.getElementById('cookie-banner');\n\n    if (existingConsent || !banner) return;\n\n    // Initialize focus manager for cookie banner\n    const focusManager = new FocusManager(banner, {\n      autoFocus: false, // Don't auto-focus banner when it appears\n      handleEscape: true, // Allow escape to close banner\n      onEscape: () => {\n        // Reject cookies when escape is pressed\n        stateManager.setState('cookieConsent', { \n          consentValue: 'rejected',\n          isVisible: false \n        }, { source: 'focus-manager-escape' });\n      }\n    });\n    \n    // Connect focus manager to state manager\n    focusManager.setStateManager(stateManager, 'cookieConsent');\n\n    // Store active animation for cleanup\n    let bannerAnimation = null;\n\n    // Initialize cookie consent state\n    stateManager.setState('cookieConsent', { \n      consentValue: existingConsent || null,\n      isVisible: false,\n      isAnimating: false\n    }, { silent: true });\n\n    // Subscribe to cookie consent state changes\n    const unsubscribe = stateManager.subscribe('cookieConsent', (newState, oldState, source) => {\n      // Handle visibility changes\n      if (newState.isVisible !== oldState.isVisible) {\n        if (newState.isVisible) {\n          performShowBanner();\n        } else {\n          performHideBanner();\n        }\n      }\n      \n      // Handle consent value changes\n      if (newState.consentValue !== oldState.consentValue && newState.consentValue) {\n        handleConsentChange(newState.consentValue);\n      }\n      \n      // Handle animation state\n      if (newState.isAnimating !== oldState.isAnimating) {\n        if (newState.isAnimating) {\n          banner.classList.add('is-animating');\n        } else {\n          banner.classList.remove('is-animating');\n        }\n      }\n      \n      // Handle focus management based on state changes\n      if (newState.isVisible !== oldState.isVisible) {\n        if (newState.isVisible) {\n          // Enable keyboard navigation when banner becomes visible\n          // Note: We don't auto-focus to avoid disrupting user flow\n          focusManager.enableFocusTrap();\n        } else {\n          // Disable focus trap when banner is hidden\n          focusManager.disableFocusTrap();\n        }\n      }\n    });\n\n    // Show banner implementation\n    const performShowBanner = () => {\n      const state = stateManager.getState('cookieConsent');\n      if (state.isVisible && state.isAnimating) return; // Prevent race conditions\n      \n      // Update state to show animating\n      stateManager.setState('cookieConsent', { isAnimating: true }, { source: 'show-start' });\n      \n      // Clean up any existing animation\n      if (bannerAnimation) {\n        bannerAnimation.cleanup();\n        bannerAnimation = null;\n      }\n\n      bannerAnimation = cookieBannerSlideUp(banner, {\n        duration: 300,\n        onComplete: () => {\n          // Update state - animation complete\n          stateManager.setState('cookieConsent', { isAnimating: false }, { source: 'show-complete' });\n          bannerAnimation = null;\n        }\n      });\n    };\n\n    // Hide banner implementation\n    const performHideBanner = () => {\n      const state = stateManager.getState('cookieConsent');\n      if (!state.isVisible && state.isAnimating) return; // Prevent race conditions\n      \n      // Update state to show animating\n      stateManager.setState('cookieConsent', { isAnimating: true }, { source: 'hide-start' });\n      \n      // Clean up any existing animation\n      if (bannerAnimation) {\n        bannerAnimation.cleanup();\n        bannerAnimation = null;\n      }\n\n      bannerAnimation = cookieBannerSlideDown(banner, {\n        duration: 300,\n        onComplete: () => {\n          // Remove from DOM after animation for better performance\n          if (banner.parentNode) {\n            banner.parentNode.removeChild(banner);\n          }\n          \n          // Update state - animation complete\n          stateManager.setState('cookieConsent', { isAnimating: false }, { source: 'hide-complete' });\n          bannerAnimation = null;\n        }\n      });\n    };\n\n    // Handle consent changes\n    const handleConsentChange = (value) => {\n      try {\n        localStorage.setItem('cookieConsent', value);\n        \n        // Dispatch custom event for analytics or other tracking\n        if ('CustomEvent' in window) {\n          const event = new CustomEvent('cookieConsentChanged', {\n            detail: { consent: value },\n          });\n          document.dispatchEvent(event);\n        }\n      } catch (error) {\n        console.warn('Could not save cookie consent preference:', error);\n      }\n    };\n\n    // Set cookie consent function\n    const setCookieConsent = (value) => {\n      stateManager.setState('cookieConsent', { \n        consentValue: value,\n        isVisible: false \n      }, { source: 'user-action' });\n    };\n\n    // Performance-optimized banner display with unified animation\n    const showBannerWithDelay = () => {\n      // Use requestIdleCallback for non-blocking execution\n      if ('requestIdleCallback' in window) {\n        requestIdleCallback(() => {\n          setTimeout(() => {\n            const currentConsent = localStorage.getItem('cookieConsent');\n            if (!currentConsent) {\n              stateManager.setState('cookieConsent', { isVisible: true }, { source: 'auto-show' });\n            }\n          }, 1000);\n        });\n      } else {\n        // Fallback for browsers without requestIdleCallback\n        setTimeout(() => {\n          const currentConsent = localStorage.getItem('cookieConsent');\n          if (!currentConsent) {\n            stateManager.setState('cookieConsent', { isVisible: true }, { source: 'auto-show' });\n          }\n        }, 1000);\n      }\n    };\n\n    // Optimized event delegation for better performance\n    const handleButtonClick = (e) => {\n      const target = e.target;\n      if (!target.matches('button')) return;\n\n      switch (target.id) {\n        case 'cookie-accept':\n          setCookieConsent('accepted');\n          break;\n        case 'cookie-reject':\n          setCookieConsent('rejected');\n          break;\n        case 'cookie-settings':\n          setCookieConsent('settings');\n          break;\n      }\n    };\n\n    // Use event delegation for better performance\n    banner.addEventListener('click', handleButtonClick, { passive: true });\n\n    // Keyboard support is now handled by the centralized FocusManager\n\n    // Show banner with optimized timing\n    showBannerWithDelay();\n\n    // Cleanup function\n    const cleanup = () => {\n      if (bannerAnimation) {\n        bannerAnimation.cleanup();\n        bannerAnimation = null;\n      }\n      focusManager.destroy();\n      banner.removeEventListener('click', handleButtonClick);\n      unsubscribe();\n    };\n\n    window.addEventListener('beforeunload', cleanup);\n    \n    // Return cleanup for external use\n    return cleanup;\n  }\n\n  // Initialize when browser is idle\n  let cleanup = null;\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n      cleanup = initializeCookieConsent();\n    });\n  } else {\n    cleanup = initializeCookieConsent();\n  }\n<\/script>"])),maybeRenderHead(),addAttribute(c,"id"),addAttribute(`opacity-0 translate-y-full transition-all duration-300 ease-in-out fixed inset-x-0 bottom-0 z-40 ${o}`,"class"),addAttribute(`fixed ${{"bottom-left":"bottom-4 left-4","bottom-right":"bottom-4 right-4","bottom-center":"bottom-4 left-1/2 transform -translate-x-1/2"}[l]} z-40 max-w-[360px] rounded-lg text-white p-4 shadow-lg bg-card`,"class"),i,s,addAttribute(r,"href"))}),"/Users/zitrono/dev/web/ralph-web/src/components/utils/CookieConsent.astro",void 0);var _a,__freeze=Object.freeze,__defProp=Object.defineProperty,__template=(n,e)=>__freeze(__defProp(n,"raw",{value:__freeze(n.slice())}));const $$Astro=createAstro("https://zitrono.github.io"),$$LoginModal=createComponent(((n,e,t)=>{const a=n.createAstro($$Astro,e,t);a.self=$$LoginModal;const{class:o="",title:i="Private Beta Access",message:s="Ralph is currently in private beta. Please contact us for access to our AI-powered private equity platform.",contactEmail:r="Konstantin@beneficious.com",id:l="login-modal"}=a.props;return renderTemplate(_a||(_a=__template(["","<div","",' role="dialog" aria-modal="true" aria-labelledby="modal-title" aria-describedby="modal-description"> <div class="absolute inset-0 bg-black/50 backdrop-blur-sm" onclick="closeLoginModal()" aria-hidden="true"></div> <div class="relative bg-card rounded-lg p-8 max-w-md w-full mx-4 border border-gray-700"> <button onclick="closeLoginModal()" class="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors" aria-label="Close modal" tabindex="0"> <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path> </svg> </button> <div class="text-center"> <h2 id="modal-title" class="text-2xl font-bold text-white mb-4">','</h2> <p id="modal-description" class="text-secondary mb-6"> ',' </p> <div class="flex flex-col sm:flex-row gap-4"> '," "," </div> </div> </div> </div> \x3c!-- Performance-optimized modal with centralized state and focus management --\x3e <script type=\"module\">\n  import { fadeIn, fadeOut, initAnimationSystem } from '../../utils/animation-manager.js';\n  import { initializeStateManager } from '../../utils/state-manager.js';\n  import { FocusManager } from '../../utils/focus-manager.js';\n\n  // Optimized modal functionality with centralized state and focus management\n  function initializeLoginModal() {\n    // Initialize systems\n    initAnimationSystem();\n    const stateManager = initializeStateManager();\n    \n    const modal = document.getElementById('login-modal');\n    if (!modal) return;\n\n    // Initialize focus manager for modal\n    const focusManager = new FocusManager(modal, {\n      autoFocus: false, // We'll handle focus manually after animation\n      handleEscape: false, // State manager handles escape globally\n      onEscape: () => {\n        stateManager.setState('loginModal', { isOpen: false }, { source: 'focus-manager-escape' });\n      }\n    });\n    \n    // Connect focus manager to state manager\n    focusManager.setStateManager(stateManager, 'loginModal');\n\n    let modalAnimation = null;\n\n    // Subscribe to login modal state changes\n    const unsubscribe = stateManager.subscribe('loginModal', (newState, oldState, source) => {\n      // Handle state-driven UI updates\n      if (newState.isOpen !== oldState.isOpen) {\n        if (newState.isOpen) {\n          performShowModal();\n        } else {\n          performHideModal();\n        }\n      }\n      \n      // Handle animation state\n      if (newState.isAnimating !== oldState.isAnimating) {\n        if (newState.isAnimating) {\n          modal.classList.add('is-animating');\n        } else {\n          modal.classList.remove('is-animating');\n        }\n      }\n      \n      // Handle focus management based on state changes\n      if (newState.isOpen !== oldState.isOpen) {\n        if (newState.isOpen) {\n          // Store focus when opening\n          focusManager.storeFocus();\n          // Enable focus trap after animation completes\n          if (!newState.isAnimating) {\n            focusManager.enableFocusTrap();\n          }\n        } else {\n          // Disable focus trap and restore focus when closing\n          focusManager.disableFocusTrap();\n          focusManager.restoreFocus();\n        }\n      }\n    });\n\n    // Show modal implementation\n    const performShowModal = () => {\n      const state = stateManager.getState('loginModal');\n      if (state.isOpen && state.isAnimating) return; // Prevent race conditions\n      \n      // Update state to show animating\n      stateManager.setState('loginModal', { isAnimating: true }, { source: 'show-start' });\n      \n      // Clean up any existing animation\n      if (modalAnimation) {\n        modalAnimation.cleanup();\n        modalAnimation = null;\n      }\n\n      // Use centralized scroll lock\n      stateManager.lockBodyScroll('loginModal', {\n        storePosition: true,\n        preventTouch: true,\n        className: 'modal-open'\n      });\n\n      // Show modal with animation\n      modal.classList.remove('hidden');\n      modalAnimation = fadeIn(modal, {\n        duration: 300,\n        onComplete: () => {\n          // Enable focus trap and focus first element\n          focusManager.enableFocusTrap();\n          \n          // Update state - animation complete\n          stateManager.setState('loginModal', { isAnimating: false }, { source: 'show-complete' });\n          modalAnimation = null;\n        }\n      });\n    };\n\n    // Hide modal implementation\n    const performHideModal = () => {\n      const state = stateManager.getState('loginModal');\n      if (!state.isOpen && state.isAnimating) return; // Prevent race conditions\n      \n      // Update state to show animating\n      stateManager.setState('loginModal', { isAnimating: true }, { source: 'hide-start' });\n      \n      // Clean up any existing animation\n      if (modalAnimation) {\n        modalAnimation.cleanup();\n        modalAnimation = null;\n      }\n\n      // Hide modal with animation\n      modalAnimation = fadeOut(modal, {\n        duration: 300,\n        onComplete: () => {\n          modal.classList.add('hidden');\n          \n          // Use centralized scroll unlock\n          stateManager.unlockBodyScroll('loginModal');\n          \n          // Update state - animation complete\n          stateManager.setState('loginModal', { \n            isAnimating: false\n          }, { source: 'hide-complete' });\n          modalAnimation = null;\n        }\n      });\n    };\n\n    // Public show/hide functions (for backward compatibility)\n    const showLoginModal = () => {\n      stateManager.setState('loginModal', { isOpen: true }, { source: 'user-action' });\n    };\n\n    const closeLoginModal = () => {\n      stateManager.setState('loginModal', { isOpen: false }, { source: 'user-action' });\n    };\n\n    // Register global functions for backward compatibility\n    stateManager.registerGlobalFunction('showLoginModal', showLoginModal);\n    stateManager.registerGlobalFunction('closeLoginModal', closeLoginModal);\n\n    // Focus management is now handled by the centralized FocusManager\n\n    // State manager handles escape key globally, but we can also listen for state changes from it\n    const globalUnsubscribe = stateManager.subscribe('loginModal', (newState, oldState, source) => {\n      if (source === 'escape-key' && newState.isOpen === false) {\n        // State manager triggered close via escape, UI will update automatically\n      }\n    });\n\n    // Cleanup function\n    const cleanup = () => {\n      if (modalAnimation) {\n        modalAnimation.cleanup();\n        modalAnimation = null;\n      }\n      focusManager.destroy();\n      unsubscribe();\n      globalUnsubscribe();\n      stateManager.unlockBodyScroll('loginModal');\n      stateManager.unregisterGlobalFunction('showLoginModal');\n      stateManager.unregisterGlobalFunction('closeLoginModal');\n    };\n\n    // Cleanup on page unload\n    window.addEventListener('beforeunload', cleanup);\n    \n    // Return cleanup for external use\n    return cleanup;\n  }\n\n  // Initialize immediately for interactive modal\n  let cleanup = null;\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n      cleanup = initializeLoginModal();\n    });\n  } else {\n    cleanup = initializeLoginModal();\n  }\n<\/script>"])),maybeRenderHead(),addAttribute(l,"id"),addAttribute(`hidden fixed inset-0 z-50 flex items-center justify-center animate-fade-in ${o}`,"class"),i,s,renderComponent(n,"Button",$$Button,{variant:"secondary",onclick:"closeLoginModal()",class:"flex-1"},{default:n=>renderTemplate`Close`}),renderComponent(n,"Button",$$Button,{variant:"primary",href:`mailto:${r}?subject=Ralph%20Beta%20Access%20Request&body=Hello%2C%20I%20would%20like%20to%20request%20access%20to%20Ralph%27s%20private%20beta.`,class:"flex-1"},{default:n=>renderTemplate`
Request Access
`}))}),"/Users/zitrono/dev/web/ralph-web/src/components/utils/LoginModal.astro",void 0);export{$$CookieConsent as $,$$LoginModal as a};