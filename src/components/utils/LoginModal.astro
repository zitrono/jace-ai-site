---
/**
 * LoginModal - Modal dialog for private beta access requests
 * @example
 * <LoginModal
 *   title="Private Beta Access"
 *   contactEmail="contact@example.com"
 *   message="Ralph is currently in private beta."
 * />
 */

import Button from '../primitives/Button.astro';
import type { BaseComponentProps } from '@/types/components';

export interface Props extends BaseComponentProps {
  /** Modal title */
  title?: string;
  /** Main message content */
  message?: string;
  /** Contact email for beta access requests */
  contactEmail?: string;
  /** HTML id attribute */
  id?: string;
}

const {
  class: className = '',
  title = 'Private Beta Access',
  message = 'Ralph is currently in private beta. Please contact us for access to our AI-powered private equity platform.',
  contactEmail = 'Konstantin@beneficious.com',
  id = 'login-modal',
} = Astro.props;
---

<div
  id={id}
  class={`hidden fixed inset-0 z-50 flex items-center justify-center animate-fade-in ${className}`}
  role="dialog"
  aria-modal="true"
  aria-labelledby="modal-title"
  aria-describedby="modal-description"
>
  <div
    class="absolute inset-0 bg-black/50 backdrop-blur-sm"
    onclick="closeLoginModal()"
    aria-hidden="true"
  >
  </div>
  <div class="relative bg-card rounded-lg p-8 max-w-md w-full mx-4 border border-gray-700">
    <button
      onclick="closeLoginModal()"
      class="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors"
      aria-label="Close modal"
      tabindex="0"
    >
      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M6 18L18 6M6 6l12 12"></path>
      </svg>
    </button>

    <div class="text-center">
      <h2 id="modal-title" class="text-2xl font-bold text-white mb-4">{title}</h2>
      <p id="modal-description" class="text-secondary mb-6">
        {message}
      </p>
      <div class="flex flex-col sm:flex-row gap-4">
        <Button variant="secondary" onclick="closeLoginModal()" class="flex-1">Close</Button>
        <Button
          variant="primary"
          href={`mailto:${contactEmail}?subject=Ralph%20Beta%20Access%20Request&body=Hello%2C%20I%20would%20like%20to%20request%20access%20to%20Ralph%27s%20private%20beta.`}
          class="flex-1"
        >
          Request Access
        </Button>
      </div>
    </div>
  </div>
</div>

<!-- Performance-optimized modal with centralized state and focus management -->
<script type="module">
  import { fadeIn, fadeOut, initAnimationSystem } from '../../utils/animation-manager.js';
  import { initializeStateManager } from '../../utils/state-manager.js';
  import { FocusManager } from '../../utils/focus-manager.js';

  // Optimized modal functionality with centralized state and focus management
  function initializeLoginModal() {
    // Initialize systems
    initAnimationSystem();
    const stateManager = initializeStateManager();
    
    const modal = document.getElementById('login-modal');
    if (!modal) return;

    // Initialize focus manager for modal
    const focusManager = new FocusManager(modal, {
      autoFocus: false, // We'll handle focus manually after animation
      handleEscape: false, // State manager handles escape globally
      onEscape: () => {
        stateManager.setState('loginModal', { isOpen: false }, { source: 'focus-manager-escape' });
      }
    });
    
    // Connect focus manager to state manager
    focusManager.setStateManager(stateManager, 'loginModal');

    let modalAnimation = null;

    // Subscribe to login modal state changes
    const unsubscribe = stateManager.subscribe('loginModal', (newState, oldState, source) => {
      // Handle state-driven UI updates
      if (newState.isOpen !== oldState.isOpen) {
        if (newState.isOpen) {
          performShowModal();
        } else {
          performHideModal();
        }
      }
      
      // Handle animation state
      if (newState.isAnimating !== oldState.isAnimating) {
        if (newState.isAnimating) {
          modal.classList.add('is-animating');
        } else {
          modal.classList.remove('is-animating');
        }
      }
      
      // Handle focus management based on state changes
      if (newState.isOpen !== oldState.isOpen) {
        if (newState.isOpen) {
          // Store focus when opening
          focusManager.storeFocus();
          // Enable focus trap after animation completes
          if (!newState.isAnimating) {
            focusManager.enableFocusTrap();
          }
        } else {
          // Disable focus trap and restore focus when closing
          focusManager.disableFocusTrap();
          focusManager.restoreFocus();
        }
      }
    });

    // Show modal implementation
    const performShowModal = () => {
      const state = stateManager.getState('loginModal');
      if (state.isOpen && state.isAnimating) return; // Prevent race conditions
      
      // Update state to show animating
      stateManager.setState('loginModal', { isAnimating: true }, { source: 'show-start' });
      
      // Clean up any existing animation
      if (modalAnimation) {
        modalAnimation.cleanup();
        modalAnimation = null;
      }

      // Use centralized scroll lock
      stateManager.lockBodyScroll('loginModal', {
        storePosition: true,
        preventTouch: true,
        className: 'modal-open'
      });

      // Show modal with animation
      modal.classList.remove('hidden');
      modalAnimation = fadeIn(modal, {
        duration: 300,
        onComplete: () => {
          // Enable focus trap and focus first element
          focusManager.enableFocusTrap();
          
          // Update state - animation complete
          stateManager.setState('loginModal', { isAnimating: false }, { source: 'show-complete' });
          modalAnimation = null;
        }
      });
    };

    // Hide modal implementation
    const performHideModal = () => {
      const state = stateManager.getState('loginModal');
      if (!state.isOpen && state.isAnimating) return; // Prevent race conditions
      
      // Update state to show animating
      stateManager.setState('loginModal', { isAnimating: true }, { source: 'hide-start' });
      
      // Clean up any existing animation
      if (modalAnimation) {
        modalAnimation.cleanup();
        modalAnimation = null;
      }

      // Hide modal with animation
      modalAnimation = fadeOut(modal, {
        duration: 300,
        onComplete: () => {
          modal.classList.add('hidden');
          
          // Use centralized scroll unlock
          stateManager.unlockBodyScroll('loginModal');
          
          // Update state - animation complete
          stateManager.setState('loginModal', { 
            isAnimating: false
          }, { source: 'hide-complete' });
          modalAnimation = null;
        }
      });
    };

    // Public show/hide functions (for backward compatibility)
    const showLoginModal = () => {
      stateManager.setState('loginModal', { isOpen: true }, { source: 'user-action' });
    };

    const closeLoginModal = () => {
      stateManager.setState('loginModal', { isOpen: false }, { source: 'user-action' });
    };

    // Register global functions for backward compatibility
    stateManager.registerGlobalFunction('showLoginModal', showLoginModal);
    stateManager.registerGlobalFunction('closeLoginModal', closeLoginModal);

    // Focus management is now handled by the centralized FocusManager

    // State manager handles escape key globally, but we can also listen for state changes from it
    const globalUnsubscribe = stateManager.subscribe('loginModal', (newState, oldState, source) => {
      if (source === 'escape-key' && newState.isOpen === false) {
        // State manager triggered close via escape, UI will update automatically
      }
    });

    // Cleanup function
    const cleanup = () => {
      if (modalAnimation) {
        modalAnimation.cleanup();
        modalAnimation = null;
      }
      focusManager.destroy();
      unsubscribe();
      globalUnsubscribe();
      stateManager.unlockBodyScroll('loginModal');
      stateManager.unregisterGlobalFunction('showLoginModal');
      stateManager.unregisterGlobalFunction('closeLoginModal');
    };

    // Cleanup on page unload
    window.addEventListener('beforeunload', cleanup);
    
    // Return cleanup for external use
    return cleanup;
  }

  // Initialize immediately for interactive modal
  let cleanup = null;
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      cleanup = initializeLoginModal();
    });
  } else {
    cleanup = initializeLoginModal();
  }
</script>
